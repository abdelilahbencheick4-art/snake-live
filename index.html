<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake AI Infinite</title>

<style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background-color: #1a1a1a;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'Segoe UI', sans-serif;
    overflow: hidden;
}

#gameInfo {
    color: white;
    text-align: center;
    margin-bottom: 15px;
    font-size: 1.2rem;
    font-weight: bold;
    letter-spacing: 2px;
}

canvas {
    background: #2b2b2b;
    border: 4px solid #4CAF50;
    border-radius: 15px;
    box-shadow: 0 0 50px rgba(76, 175, 80, 0.3);
    max-width: 95vw;
    max-height: 80vh;
}
</style>
</head>

<body>

<div id="gameInfo">
    Score: <span id="scoreVal">0</span>
</div>

<canvas id="game"></canvas>

<script>

// CONFIG
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const TILE = 20;
const COLS = 15;
const ROWS = 25;

canvas.width = TILE * COLS;
canvas.height = TILE * ROWS;

const COL_SNAKE = "#4CAF50";
const COL_APPLE = "#ff4757";
const COL_BG_1 = "#2b2b2b";
const COL_BG_2 = "#333333";

let snake = [];
let apple = {};
let score = 0;

const GAME_SPEED = 40;

// INITIALISATION
function init() {
    const startX = Math.floor(COLS / 2);
    const startY = Math.floor(ROWS / 2);

    snake = [
        {x: startX, y: startY},
        {x: startX, y: startY + 1},
        {x: startX, y: startY + 2}
    ];

    score = 0;
    spawnApple();
    updateScore();
}

function spawnApple() {
    let valid = false;
    while (!valid) {
        apple = {
            x: Math.floor(Math.random() * COLS),
            y: Math.floor(Math.random() * ROWS)
        };
        valid = !snake.some(s => s.x === apple.x && s.y === apple.y);
    }
}

// IA BFS
function getBestMove() {
    const head = snake[0];
    let path = bfs(head, apple);

    if (path && path.length > 0) {
        return {x: path[0].x - head.x, y: path[0].y - head.y};
    }

    // fallback simple
    return {x: 0, y: -1};
}

function bfs(start, target) {
    let queue = [[start]];
    let visited = new Set();
    visited.add(start.x + "," + start.y);

    while(queue.length > 0) {
        let path = queue.shift();
        let current = path[path.length - 1];

        if(current.x === target.x && current.y === target.y) {
            return path.slice(1);
        }

        const neighbors = [
            {x:0, y:-1},
            {x:0, y:1},
            {x:-1, y:0},
            {x:1, y:0}
        ];

        for(let n of neighbors) {

            let nx = current.x + n.x;
            let ny = current.y + n.y;

            // WRAP (portail)
            if (nx < 0) nx = COLS - 1;
            if (nx >= COLS) nx = 0;
            if (ny < 0) ny = ROWS - 1;
            if (ny >= ROWS) ny = 0;

            let next = {x:nx, y:ny};
            let key = nx + "," + ny;

            let isTail = (
                nx === snake[snake.length - 1].x &&
                ny === snake[snake.length - 1].y
            );

            if((!snake.some(s => s.x === nx && s.y === ny) || isTail)
                && !visited.has(key)) {

                visited.add(key);
                queue.push([...path, next]);
            }
        }
    }
    return null;
}

// UPDATE LOOP
function update() {

    let move = getBestMove();

    let head = {
        x: snake[0].x + move.x,
        y: snake[0].y + move.y
    };

    // WRAP WALLS
    if (head.x < 0) head.x = COLS - 1;
    if (head.x >= COLS) head.x = 0;
    if (head.y < 0) head.y = ROWS - 1;
    if (head.y >= ROWS) head.y = 0;

    snake.unshift(head);

    if (head.x === apple.x && head.y === apple.y) {
        score++;
        updateScore();

        if (snake.length >= COLS * ROWS - 1) {
            alert("VICTOIRE !");
            init();
            return;
        }

        spawnApple();
    } else {
        snake.pop();
    }

    draw();
}

// DRAW
function draw() {

    // Fond damier
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            ctx.fillStyle = (x + y) % 2 === 0 ? COL_BG_1 : COL_BG_2;
            ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
        }
    }

    // Pomme
    ctx.fillStyle = COL_APPLE;
    ctx.beginPath();
    let ax = apple.x * TILE + TILE/2;
    let ay = apple.y * TILE + TILE/2;
    ctx.arc(ax, ay, TILE/2 - 2, 0, Math.PI * 2);
    ctx.fill();

    // Snake continu lisse
    ctx.lineWidth = TILE - 4;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = COL_SNAKE;
    ctx.shadowColor = "rgba(76, 175, 80, 0.5)";
    ctx.shadowBlur = 10;

    ctx.beginPath();
    let startX = snake[0].x * TILE + TILE/2;
    let startY = snake[0].y * TILE + TILE/2;
    ctx.moveTo(startX, startY);

    for (let i = 1; i < snake.length; i++) {
        let px = snake[i].x * TILE + TILE/2;
        let py = snake[i].y * TILE + TILE/2;
        ctx.lineTo(px, py);
    }

    ctx.stroke();
    ctx.shadowBlur = 0;

    // Yeux
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(startX - 3, startY - 3, 2, 0, Math.PI*2);
    ctx.arc(startX + 3, startY - 3, 2, 0, Math.PI*2);
    ctx.fill();
}

function updateScore() {
    document.getElementById("scoreVal").innerText = score;
}

init();
setInterval(update, GAME_SPEED);

</script>

</body>
</html>
