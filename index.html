<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake AI Stable</title>

<style>
html,body{
margin:0;
height:100%;
background:#111;
display:flex;
flex-direction:column;
justify-content:center;
align-items:center;
font-family:Arial;
}

#scoreBoard{
color:white;
font-size:22px;
margin-bottom:10px;
}

canvas{
border:4px solid #4CAF50;
border-radius:20px;
box-shadow:0 0 40px rgba(76,175,80,.6);
}
</style>
</head>
<body>

<div id="scoreBoard">Score: <span id="score">0</span></div>
<canvas id="game"></canvas>

<script>

const TILE=20;
const COLS=20;
const ROWS=20;

const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

canvas.width=TILE*COLS;
canvas.height=TILE*ROWS;

let snake=[];
let apple={};
let score=0;

let cycle=[];

// Création cycle Hamiltonien zigzag
for(let y=0;y<ROWS;y++){
if(y%2===0){
for(let x=0;x<COLS;x++) cycle.push({x,y});
}else{
for(let x=COLS-1;x>=0;x--) cycle.push({x,y});
}
}

function init(){
snake=[cycle[0],cycle[1],cycle[2]];
score=0;
spawnApple();
updateScore();
}

function spawnApple(){
do{
apple={
x:Math.floor(Math.random()*COLS),
y:Math.floor(Math.random()*ROWS)
};
}while(snake.some(s=>s.x===apple.x && s.y===apple.y));
}

function update(){

let head=snake[0];
let index=cycle.findIndex(c=>c.x===head.x && c.y===head.y);
let nextCycle=cycle[(index+1)%cycle.length];

// tentative raccourci vers pomme
let shortcut=getSafeShortcut(head);

// si raccourci sécurisé on le prend
let next=shortcut ? shortcut : nextCycle;

snake.unshift(next);

if(next.x===apple.x && next.y===apple.y){
score++;
updateScore();
spawnApple();
}else{
snake.pop();
}

draw();
}

function getSafeShortcut(head){

let dx=apple.x-head.x;
let dy=apple.y-head.y;

let moves=[
{x:Math.sign(dx),y:0},
{x:0,y:Math.sign(dy)}
];

for(let m of moves){

let nx=head.x+m.x;
let ny=head.y+m.y;

if(nx<0||ny<0||nx>=COLS||ny>=ROWS) continue;

let collision=snake.some(s=>s.x===nx && s.y===ny);
if(collision) continue;

// vérifier que case suivante est dans futur du cycle
let headIndex=cycle.findIndex(c=>c.x===head.x && c.y===head.y);
let nextIndex=cycle.findIndex(c=>c.x===nx && c.y===ny);

if(nextIndex>headIndex){
return {x:nx,y:ny};
}
}

return null;
}

function draw(){

for(let y=0;y<ROWS;y++){
for(let x=0;x<COLS;x++){
ctx.fillStyle=(x+y)%2?"#2a2a2a":"#333";
ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
}
}

ctx.fillStyle="red";
ctx.beginPath();
ctx.arc(
apple.x*TILE+TILE/2,
apple.y*TILE+TILE/2,
TILE/2-3,
0,Math.PI*2
);
ctx.fill();

ctx.lineWidth=TILE-6;
ctx.lineCap="round";
ctx.lineJoin="round";
ctx.strokeStyle="#4CAF50";

ctx.beginPath();
ctx.moveTo(
snake[0].x*TILE+TILE/2,
snake[0].y*TILE+TILE/2
);

for(let i=1;i<snake.length;i++){
ctx.lineTo(
snake[i].x*TILE+TILE/2,
snake[i].y*TILE+TILE/2
);
}

ctx.stroke();

ctx.fillStyle="white";
ctx.beginPath();
ctx.arc(snake[0].x*TILE+TILE/2-3,snake[0].y*TILE+TILE/2-3,2,0,Math.PI*2);
ctx.arc(snake[0].x*TILE+TILE/2+3,snake[0].y*TILE+TILE/2-3,2,0,Math.PI*2);
ctx.fill();
}

function updateScore(){
document.getElementById("score").innerText=score;
}

init();
setInterval(update,60);

</script>
</body>
</html>
